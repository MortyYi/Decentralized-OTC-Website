---
sort: 4
---

# 司法市场化
## 司法市场化与链上法院
>我们认为,现在的全球司法系统腐败而低效,缺乏公正判决的市场机制.在哈耶克链上,我们将会推行司法的市场化,法院这样的裁判组织,更应该是市场化运作的裁判服务组织.

>你可以想象一下,Bob和Alice在哈耶克链上签订一份商业合同,为了使得双方履约,他们各自向哈耶克链上的一个智能合约缴纳一定的哈耶克币作为违约赔偿金.如果双方按照签订的协议完全履约而无异议.则他们不需要任何第三方的裁判服务.

>如果Bob和Alice在履约过程中,出现了纠纷.按照以前的处理方式,那么,他们必须起诉对方到有管辖权的法院.

>如果你有过在法院诉讼的经历,你就会知道,这是一场噩梦.

>首先,你面对的可能是繁杂的法律条文.而且,Bob和Alice的双方约定的合同条款可能会被法院所否决.

>最近,我有两位朋友在中国大陆出现一起借贷纠纷,Mr Dai向Mr Zhu借款30万元人民币,约定半年后偿还,利息为20%,如果Mr Dai逾期不能偿还,则需要向Mr Zhu支付惩罚性的30%的赔偿金.

>不幸的是,Mr Dai到期未能偿还贷款.Mr Zhu将Mr Dai诉诸当地中国法院,在中国最低一级的县级法院,法官无视他们双方签订的合同的本意,依据中国法律,对超过银行利率4倍的高额利息部分不予支持.

>这样看上去好像禁止了高额利息的借款.表面上保护了Mr Dai免受高利贷的损害.

>如果我们仔细思考,就会发现,事实上,这只会使得Mr Dai以后融资更加困难,因为即便他想以更高的利率借款也会变得异常困难.因为,谁也无法相信Mr Dai哪怕在合同中约定愿意支付很高的利息.放贷人也会清楚,这样的合同最终不会得到中国法院的支持.出借人不得想出其他约束借款人的条件.使得借款人借贷成本实际更高.

>我们有理由相信,中国民间借贷成本高昂,其中一个原因就是因为中国司法系统愚蠢的限制了市场利率.违背市场规律,其结果当然事与愿违.

>限制市场的法律,表面上看是良法,事实上却是恶法,这种法律事实上使得Mr Dai这样的借款人更难在市场上融资.

>这样的事情,其实不只是出现在中国大陆,在其他许多国家同样出现.政府和立法机关以良好的愿望制定法律,想要保护弱势的一方,实际上恰恰起到相反的效果.因为这破坏了市场,必然事与愿违.

>哈耶克认为,市场从来不会失效,当你遏制高利率借贷,市场一定会通过另外的方式来调节借贷利率.

>在美国和欧洲,立法机关制定最低工资法,想保护最底层的劳工.实际上却使得他们失业,生活更加的艰难.因为,如果一个人的能力只能在市场上赚到5美元/小时.立法机关制定最低12.5美元/小时的最低工资法.守法雇主的唯一选择就是不再雇佣他.弱势群体要么失业,要么到不合法的工作场所工作.生活自然更加艰难.

>基于以上这些原因,所以,我们致力于推行哈耶克链上的司法市场化.

>在哈耶克链上,任何个人或者组织,可以匿名或者实名的方式设置一个法院,这个法院实际上是一个有人(法官)控制的智能合约.在类似DOTC交易所这种交易智能合约中,交易的双方可以自行约定一个双方满意的链上法院.当交易双方或者多方出现交易纠纷的时候,任何一方可以在链上发起起诉.将违约方起诉至当初合同签订时指定的链上法院.链上法院依据什么来判决呢?

>第一,证据:原告与被告将会向链上法院提交各自的证据.

>第二.当初合同签订的原文.这种合同原文将会是法院判决的最根本依据.比如,在本文前面提到的借款纠纷中,双方当初签订的借款合同将会被链上法院完全支持.

>第三,既然是法官,那么一定是存在一定的自由裁量权.这种自由裁量权,是基于法官内心的关于公平与正义的认识,也就是价值观.


## DOTC官方法院

>如果交易双方发生了纠纷。而且，在发布订单的时候,您是选择的DOTC官方法院，则请您使用telegram 联系我们的电报telegram: [hayeklink](https://t.me/hayeklink).

>DOTC官方法院的诉讼收费标准是:币安链：0.1BNB,哈耶克链：1000HYK，OKEx chain(OEC):1.0OKT

>买卖双方都可以发起诉讼，在发起诉讼的时候，由发起诉讼的一方支付诉讼费。所以，需要注意的是:

>如果您是卖家，在创建订单的时候，为了避免您的损失，建议您在发布订单的时候，将买家违约金的金额至少要设置得高于诉讼费。这样，如果买家点击购买你的订单之后不付款，卖家需要起诉，那么，一般来说，法院会判决将买家支付的违约金赔偿给卖家。可以弥补卖家损失。

>如果您是买家,则建议购买在订单中显示卖家违约金至少高于法院诉讼费的订单.否则,卖家有可能在您付款之后并不为您确认订单.这样,您就必须自己支付诉讼费来发起诉讼.从而会给您带来损失.

## 自建法院

>DOTC系统支持第三方法院，任何人可以创建自己的法院来承担裁判任务，利润则是您收取的诉讼费，您可以参考我们公开的法院代码,撰写您自己的法院智能合约。如果您创建了您的法院合约，需要加入的我们的法院合约列表当中去(这不是必须的)。则请您与我们取得联系telegram: [hayeklink](https://t.me/hayeklink)。

>自建法院合约如果没有加入到我们的法院合约列表文件.在订单中则会显示为"未经验证的法院".

>如果您需要使用自建法院合约,那么,卖家在发布订单的时候,需要自行填写自己的法院合约地址.

>买家则需要注意,如果您看到的卖家订单中显示的法院为"未经验证的法院",则需要您自行判断该法院是否具有可信度.

>我们欢迎全球各地的律师,法官,律师事务所到区块链上建立自己的链上法院合约.我们相信,这是未来区块链链上治理的重要一环.您及早的介入这个行业,将会取得先机.

### 如何自建法院
>第一步，您首先要学习有关智能合约编写的相关知识，智能合约一般非常短小，稍微有一点编程基础的人，都可以很快学会智能合约的编写。编写智能合约，和其他的计算机程序编写一样，有许多不同的编程语言，不过，目前最主流的语言是Solidity语言，这是一种类似Java的语言。如果对solidity语言完全没有接触过，建议你先访问[solidity的官方网站的文档](https://docs.soliditylang.org/)。也可以在Google搜索Solidity的各种语言的教程。

>当你简单了解了智能合约以及Solidity语言之后，那么，你可以查看本网站的开放代码页面，找到有关Juadge合约的链接。可以查看我们官方法院或者其他法院的代码来进行参考学习。

官方法院的源代码：
```Solidity
/**
 *Submitted for verification at BscScan.com on 2021-12-31
*/

//SPDX-License-Identifier:MIT
//optimizer 30000 0.8.10 default
pragma solidity ^0.8.10;
pragma experimental ABIEncoderV2;
interface judgeStandard{
    function dispute(uint id,uint8 requirePrecentSubjectToseller,uint8 requirePrecentDepositToseller) external payable returns(bool r);
    function getResult(uint id) external returns (uint8 precentSubjectToseller,uint8 precentDepositToseller,bool resultState);
    function getArbitrationFee(uint id) external returns(uint arbitrationFee);
    
    function getUrl() external returns(string memory);
    function getName() external returns(string memory);
}
    struct Order{
       uint salenumber;
       uint price;
       uint lockedblocknumber;
       address payable seller;
       address payable buyer;
       address arbitration;
       address erc20address;
       uint sellerLiquidataedDamages;
       uint buyerLiquidataedDamages;
       string describe;
       string Currency;
       uint8 state;   //0 put 1 lock 2 complete 3 judge
    }
interface trading{
       function getOrderInfo(uint index) external view returns(Order memory);
}
contract judge{
    struct Case{
        string sellerProof;
        string buyerProof;
        uint8 precentSubjectToseller;
        uint8 precentDepositToseller;
        bool resultState;
        uint disputedBlockNum;
    }
    struct CaseProof{
        uint id;
        Case caseInfo;
        Order orderInfo;
    }
     mapping(uint=>Case) public allCase;
     mapping(address=>uint[]) myCase;
     uint[] public judgingCase;
     address payable private owner;
     mapping(address => bool) public judger;
     string public constant url = "https://dotc.trade/cn/court.html";
     string public constant name =  "D-OTC Official Court";
     uint public Fee;
     address public tradingAddress=0x5De2994114e740A3BD049c74D6aE06529F6C99c6;
     
     constructor(){
        owner=payable(msg.sender);
        Fee=1000 ether;
    }
    
     function getUrl() public pure returns(string memory){
         return url;
     }
    
     function getName() public pure returns(string memory){
         return name;
     }

     function setFee(uint fee) public returns(bool){
         require(owner==msg.sender);
         Fee=fee;
         return true;
     }

     function toJudge(uint id,uint8 precentSubjectToseller,uint8 precentDepositToseller) public returns(bool){
         require(msg.sender==owner||judger[msg.sender],"you can not judge");
         require(allCase[id].disputedBlockNum!=0,"wrong id to judge");
         allCase[id].precentDepositToseller=precentDepositToseller;
         allCase[id].precentSubjectToseller=precentSubjectToseller;
         allCase[id].resultState=true;
         return true;
     }
     
     function dispute(uint id,uint8 requirePrecentSubjectToseller,uint8 requirePrecentDepositToseller) public  payable returns(bool r){
         require(msg.value==Fee,"wrong msgvalue");
         require(msg.sender==tradingAddress,"wrong smart contract address");
         require(allCase[id].disputedBlockNum==0,"this case is accepted,you can not dispute it again.");
         judgingCase.push(id);
         allCase[id].disputedBlockNum=block.number;
         Order memory d = trading(tradingAddress).getOrderInfo(id);
         myCase[d.seller].push(id);
         myCase[d.buyer].push(id);
         return true;
     }
     
     function getResult(uint id) public view returns (uint8 precentSubjectToseller,uint8 precentDepositToseller,bool resultState){
         precentSubjectToseller=allCase[id].precentSubjectToseller;
         precentDepositToseller=allCase[id].precentDepositToseller;
         resultState=allCase[id].resultState;
     }
     
     function getArbitrationFee(uint id) public view returns(uint arbitrationFee){
         arbitrationFee= Fee;
     }
     
     function getWaitingForJudgingCase(uint linenumber) public view returns(CaseProof[] memory r){
         r = new CaseProof[](linenumber);
         uint x=0;
         uint length=judgingCase.length;
         for(uint i=0;i<length&&x<linenumber;i++){
             uint index = judgingCase[length-i-1];
             if(allCase[index].resultState==false){
                 CaseProof memory temp = CaseProof(index,allCase[index],trading(tradingAddress).getOrderInfo(index));
                 r[x]=temp;
                 x++;
             }
         }
     }
     
     function getMyCase(address sender,uint linenumber) public view returns(CaseProof[] memory r){
         r = new CaseProof[](linenumber);
         uint x=0;
         uint length=myCase[sender].length;
         for(uint i=0;i<length&&x<linenumber;i++){
             uint index = myCase[sender][length-i-1];
             CaseProof memory temp = CaseProof(index,allCase[index],trading(tradingAddress).getOrderInfo(index));
             r[x]=temp;
             x++;
         }
     }

     function uploadProof(uint index,string memory proof) public returns(bool){
        Order memory d = trading(tradingAddress).getOrderInfo(index);
        require(msg.sender==d.buyer||msg.sender==d.seller,"You can not Upload proof for this case");
        if(msg.sender==d.seller){
            allCase[index].sellerProof=proof;
        }else{
            allCase[index].buyerProof=proof;
        }
        return true;
     }

     function withdraw(uint num) public returns(bool){
         require(msg.sender==owner,"you are not owner");
         owner.transfer(num);
         return true;
     }
    
    function manageJudger(address judgerAddr,bool state) public returns(bool){
        require(msg.sender==owner,"you can not manage judger");
        judger[judgerAddr]=state;
        return true;
    }
}
``` 
>以上代码，是我们官方法院在币安链上的源代码。

>您可以直接复制以上代码，[访问 Remix](https://remix.ethereum.org/) ，创建一个test.sol文件，将以上代码复制进去。然后，链接您的Metamask钱包，发布在对应的区块链上。

>关于如何在Remix上编写和发布智能合约。请搜索相关文档。或者点这里查看[Remix官网文档](https://remix-ide.readthedocs.io/)

#### 代码解释

##### 法院合约的接口标准
```key

interface judgeStandard{
    function dispute(uint id,uint8 requirePrecentSubjectToseller,uint8 requirePrecentDepositToseller) external payable returns(bool r);
    function getResult(uint id) external returns (uint8 precentSubjectToseller,uint8 precentDepositToseller,bool resultState);
    function getArbitrationFee(uint id) external returns(uint arbitrationFee);
    
    function getUrl() external returns(string memory);
    function getName() external returns(string memory);
}

```

>以上代码，是一个法院的接口标准

>在你的法院合约中，最少必须要实现接口中的5个函数。我们分别来解释

>judge合约是一个生成和保存以及提供许多判决书的智能合约。

>dispute函数，这个函数是由用户调用，用来发起争议（起诉），后续包括三个参数，发起争议的编号unit id，一般来说，在DOTC系统中，这个编号就是DOTC系统中的订单编号。uint8 requirePrecentSubjectToseller,uint8 requirePrecentDepositToseller这两个参数，分别是发起争议者的诉讼请求。都是两个整数。requirePrecentSubjectToseller参数的含义是指起诉者希望法院判决卖家（seller)拿走订单中的所售资产(一般是USDT)的百分比。比如，这个参数起诉者填写的是31，意味着，他认为卖家应该拿走该订单中的USDT总额的31%。requirePrecentDepositToseller参数代表的是起诉者认为卖家（seller)应该拿走违约金总额的比例。一般来说，一个订单中包括了买家支付的违约金以及卖家支付的违约金。（卖家违约金+买家违约金）*requirePrecentDepositToseller，就是支付给卖家的违约金总额。

>你可能会问，剩余的部分给了谁？对了，剩余的部分全部给了买家。不会有任何多余的部分转给DOTC合约的开发者，或者法院自身。也就是说，无论法院如何判决，不影响DOTC项目方以及法院的利益。

>dispute函数只是起诉者在起诉的时候希望法院这样判决。但是，在你的法院判决流程中，你可以不用按照起诉者的诉讼请求进行判决。这个时候，法院必须要输出一个判决结果。就是法院认为买卖双方应该拿到的比例。

>getResult函数，就是返回法院经过调查以后所认为公平的判决结果。输入参数unit id，就代表在dotc中的订单编号。返回结果包括三个参数：uint8 precentSubjectToseller,uint8 precentDepositToseller,bool resultState。其中precentSubjectToseller是法院的判决书认为卖家应该分配到订单中的所售资产（一般是USDT)的百分比。requirePrecentDepositToseller参数代表的是法院认为卖家（seller)应该拿走违约金总额的比例。一般来说，一个订单中包括了买家支付的违约金以及卖家支付的违约金。（卖家违约金+买家违约金）*requirePrecentDepositToseller，就是支付给卖家的违约金总额。另外，还有一个返回结果resultState,这是一个布尔值。如果返回的是true，就代表这个判决是真实有效的。如果返回的是false，则代表这个判决实际上还没有生成。

>这个getResult函数是由买卖双方在DOTC系统订单中点击执行判决，会执行DOTC的Trading合约中的执行(Excute)函数，然后由Excute函数调用订单中指定的法院合约的getResult函数，取得结果，然后，根据法院的判决结果分配订单中的资产。是的，Trading合约是DOTC的核心合约，它保管着买卖双方的所售资产以及违约金。也只有Trading合约能够对双方的资产进行转账操作。法院合约是不能直接分配买卖双方的资产的。而且，Trading合约也只是能根据法院的判决结果来处置买卖双方已经支付到订单中的资产，而不能处置买卖双方钱包里的未转移到订单中的其他资产。

>getArbitrationFee这个函数，输入参数是uint id，一般来说是dotc中的订单编号。返回的结果是仲裁费金额（诉讼费），支付的币种是该区块链上的基础币（比如币安链上是BNB，哈耶克链上是HYK)。在这个函数中，法院合约可以简单的返回一个固定值。也可以是根据订单里面的资产数量计算出一个按比例收取的诉讼费金额。

>getUrl函数，直接返回该法院合约的网站地址。一般来说，在DOTC系统中，会显示在法院名称旁边。用户通过这个网站链接访问法院的官网。在官网联系法院的法官进行举证与沟通。也就是说，法院的门户。

>getName只是返回法院的名称。

>任何人编写的智能合约，如果实现了以上几个函数，那么，就是一个可以运行的法院合约。




